---
layout: post
title: ClippingKK 发布啦
tags: code clippingkk kindle js flutter windows
---

## 背景

我大概是在一六年买了台 kindle，起初不太适应墨水屏和读书，之后用久了渐渐习惯，用 kindle 也算是读了一部分书。kindle 给我的各方面感觉都很好，好到可以把很多 bug 当做 feature 来用(比如墨水屏翻页缓慢)，而且电子书也比较便宜。

起初对于 kindle 并没有什么太多的期待，只是读读书就可以了。可是后来偶然间知道可以做摘录，于是在看到一些比较好的句子的时候就会注意再摘录一下。再后来我发现摘录之后的步骤基本就停滞了，会存在一个 `documents/My Clippings.txt` 的文件中，只是这个文件不是给普通用户看的。所以产生的后果就是，一旦摘录之后，就会忘记有这个东西，再找很难找回。

后来多方寻找过各种方案，一个 [clippings.io](https://www.clippings.io) 看起来还不错，于是就用了，只是用了一段时间感觉这个产品做得比较一般，包括界面，网站加载，预览等方面都不够好。

但是那个时间点也没有太多想法，而且那段时间有几本实体书要看，于是这个事情就搁置了。

后来由于对 Windows 产生了浓厚的兴趣，想要学一把 Windows UWP 的开发，然后也想起来了 kindle 摘录的事情，思来想去比较合适。于是大概在一八年年中开始了这个项目的开发。

### 2018Q3 & Q4

最初只是想开发一款 Windows 客户端。原因有以下几点：

1. 想学 Windows 开发

2. 做 web 项目会很快，对我没有太大的成长帮助

3. 希望能做到自动导入，而不是用户手动选文件。这个能力据我所知 web 是不具备的，native 很可能是具备的。

Windows 客户端的开发进展非常缓慢。主要原因有两个：一是不会 Windows 开发，需要现学。二是没什么时间，工作日基本到家就九、十点了。好在 Windows 开发非常舒心而且快乐。

先从基本布局开始学，然后到简单的 API，再到网络，文件系统，组件化，i18n 等。所以在十一月份的时候买了微软开发者，发布了第一个版本。第一个版本非常的简单：拖拽解析 My Clippings.txt 文件，序列化数据保存到本地的 sqlite。然后一个 ListView 展示。详情页面会去拉一下豆瓣图书的 API 展示一下书里的基本信息。

上线完之后，我发现连我自己都不常用这个 app。 我用电脑的时候目的都很明确，要么玩游戏，要么写代码，要么看电影. 电脑作为一个上传的接口还可以，但是常用绝对谈不上。而且我的整理出的摘录也只是存在电脑里，基本没什么用。

于是开始策划写后端，至少先把本地解析的数据同步到服务器上。

后端的技术选型没有犹豫太久，因为之前 [Athena](https://db.annatarhe.com) 这个项目，我已经很明确地知道了自己喜欢什么技术栈。然后后端我的预期是尽量快，没必要追求太新的技术，做个能用的后端就成了。所以直接拿 iris 开发，也没接 GraphQL。 不过不仅仅是图方便，没有用 GraphQL 的另一个原因是担心语言支持不够好，像我这样写 C# 和 dart 的基本都没报什么期望。

后端的大部分接口还挺简单的，只是一个上传的接口有些难办，因为上个版本已经有了一个本地数据库，所以就涉及到了本地数据和远程数据的同步问题，还牵扯到了版本的概念，现在想想压根就不应该这么搞，当时这个问题挺棘手，问了一些同事的思路最后写了出来。这个后端为了简单，甚至连 cache 都没加几个。不过想来想去，pg 那么稳，流量全打过去算了（真实情况是其实根本没什么流量 😂）。

很快，后端就写出来了。直接拿 docker-compose up 到服务器。

然后为了把数据能够和服务器同步，windows 客户端又改了一版，发布到了商店，这个版本在商店定义为了 2.0 的版本，但是可能叫 pre.alpha 可能更合适.

之后考虑在移动端上做读的客户端。刚好 Flutter 很火，顺手就拿来写了。可是事不如人愿，写着写着总感觉 Flutter 不够好，写到一半想要保存图片到本地，然后发现需要授权，而授权这个步骤是在 native 那一层做的。当时写着写着就觉得不如直接写 native 来得爽快。于是花了两天用 kotlin 写出了 flutter 两个星期的工作量（时间差这么多一部分也是因为对 flutter 不如对 android 熟）。写出来以后我还挺满意的，可惜我用的是 iPhone. 

所以很尴尬，在尝试拿 Android 机作为主力机使用的半小时后，我又放弃了 kotlin 版本的移动客户端，转而又开始写了 flutter。

### 2019Q1

所以 Q1 的时候，在三月初终于上线了手机客户端，不过因为付不起苹果的开发者保护费，只上线了安卓版，[发布在酷安](http://www.coolapk.com/apk/219832)。

Q1 还有一个大的 feature。我花了大概三五天写了一个 web 版。现在看起来 web 版的上传体验更好。在界面的展示以及动画上，都比我蹩脚的 windows 水平高很多。在 windows 版缺失的生成分享图功能也在 web 版上花了几个小时写出来了。

可以点 [这里](https://kindle.annatarhe.com) 体验一下，麻烦的点在于需要用邮箱注册账户，由于很多商业限制的原因，没有接微信，微博等第三方账号，所以整个流程可能会冗长一些。然后登录成功之后还需要点击上传的按钮，把自己的 my clippings.txt 拖进去。

值得一提的是，在项目上线的时候，服务监控顺便加了一些。到目前为止，后端项目接了 new relic 做性能监控，sentry 作为错误监控。至于日志没有上 elk，一是麻烦，二是没必要，三是服务器可能真的扛不住。

前端部分也有，web 上接入了 new relic，功能同样是做性能监控。只是目前还没有发现有什么性能问题 (毕竟要对得起自己的 title 😂). web 端用 [fathom]() 替换掉了 ga(google TODO)，原因在于担心 ga 日志上报的准确性，还有对于数据存储方面的疑虑。至于 fathom 简直是太简单了，只有简单的 pv, uv，其他啥都没。仔细想了想，还算符合欧盟隐私协议了，算不算是个国际化看齐的项目呢 :)

mobile 版是用的 flutter 写的，接了 sentry。

这些工具我之前是不太在乎的，觉得只要是工作做完就可以了。只是随着认知的不断拓展，认识到了一个只是单纯写自己工作代码的程序员是不太够的。一个非常大的问题是我不会推广。所以偶尔蹩脚腼腆地在朋友圈发一波截图，靠口述告诉一些朋友，这就是所有的推广了。

### 2019Q2

我在年初订的 OKR 到现在进度很是缓慢。我觉得原因在于对自己的这个产品还是不够自信。功能上比较单薄。唯一算是比较满意的是开发很晚，用时很短的 web 版，但是 web 版功能依旧非常单薄。mobile 版由于 iOS 上架需要每年 688 元的费用原因，我是不想上架，直接导致的后果是抛弃了 iOS 用户 (虽然 iOS 版本运行地非常好)

在 Q2 终于发现 github oauth 要求非常低，既不用缴保护费，也不需要工商局资质审核，所以顺手就拓展了 auth 接口，花了两个晚上接入了 github 登录。这样用户只要有 github 账户，只要点一下 github 按钮登录就完成了，大大缩短了整个注册登录流程。

在 q2 给一个朋友安利的时候发现接口尴尬地 500 了，花了两天终于解决了 bug 之后，痛定思痛开始写单元测试, 接了免费的 travis ci。web 部分写了 parser 的各种测试，那段解析的代码覆盖率是 100% 了。后端目前只是简单的登录注册测试。

我发现 go 写测试实在是太烦了。想要 mock 个对象竟然如此困难，还得接个 mock 的包生成代码。相比之下 jest 和 rails 的测试太方便了。各种 describe 结构灵活，mock 可以指定自己写的包，http response 怎么爽怎么返回。静态语言的弊病？也许吧，但是我想肯定可以有更优雅的解决方式。

Q2 还完成了书摘组织结构的迁移：第一版的结构是所有的书摘作为一个 list 展示出来，在第二版的时候按照书目的形式重新组织了一遍。目前在移动版和 web 版都部署了 —— 只是差了最初的 windows 版。

## 技术概览

我这里的后端指的是大后端，是流量打到服务器之后的所有流程，前端是流量在发到服务器之前的所有流程。

### backend

整体概览是：服务器 --> nginx --> docker --> go server --> redis/PostgresQL 这样的结构, 很多企业级应用会在 nginx 做一层非常复杂的网关，我也曾考虑过用 [kong]() 来实验一下，加上 prometheus 这些，复制出一套企业级架构。只是考虑到我的服务器只是简陋的单核 1G 内存的服务器，能把程序跑起来就已经很艰难了，就不整这么多事情了。没有尝试 k8s 也是一样的原因。这台机器大概是跑不起来 k8s 的，而且我只有一台服务器。

就像之前所言，后端语言主要是 golang。选 golang 是因为我后端会的语言没几个： ruby 不能完全掌控, php 已经是历史淘汰的路上了，java 冗长复杂。至于 nodejs, 要知道我可是个 js 黑粉. 

最终选择了 golang 有几个很大的好处：

1. 终于不用纠结 `isEmpty($a)` 和 `$a === ''` 的区别了。
2. 不用考虑啥叫 `NaN`, 什么是 `undefined` 了。
3. 整个 http server 跑起来只要 **5MB** 运行内存，乞丐版服务器得到了喘息。
4. 想异步, 直接 `go`, 再也不用各种 callback 包装 promise
5. 不用加各种乱七八糟的库和框架了，一个 install 装下半个地球的日子再见了。

当然我也得到了一些烦人的东西：

1. `if err != nil {}` 占了代码库的三分之一
2. testing 很难写

在包管理方面，vscode 支持 go modules 之前我是没有包管理的，所有代码全都用 go get 到 $GOPATH 下。在 vscode 支持之后，就跑了一遍 `go mod tidy` 完成了包管理的迁移。说起来这个问题可能对我没那么复杂，但是很多很多人对此诟病已久，很大的原因在于最近很流行 monorepo 的概念，而且 google 用 bazel 作为 go 的依赖管理，所以很多用 go 的公司自然也就上了 bazel。 然而 bazel 这个东西很是魔幻而且不可预期。这个东西烦躁到我们厂里的某个同事指着人鼻子骂 bazel 是傻逼，推 bazel 的人也是傻逼







### web frontend

### mobile frontend
























